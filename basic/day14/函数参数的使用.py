# -*-coding:utf-8-*-
# @作者：haiyu.ma
# @创建日期：2020-11-22 23:52 
# @Software：PyCharm
# ----------------------------------------------------------------------------
# 一 形参与实参介绍:
# 函数的参数分为形式参数和实际参数，简称形参和实参：
# 形参：在定义函数时，括号内声明的参数。相当于变量名。形参本质就是一个变量名，用来接收外部传来的值。
# 实参：在调用函数时，括号内传入的值。相当于变量值。值可以是常量、变量、表达式或三者的组合
# 形参与实参的关系：
# 1.在调用有参函数时，实参（值）会赋值给形参（变量名）。（在Python中，变量名与值只是单纯的绑定关系）
# 2.这种绑定关系只能在函数体内使用
# 3.形参与实参的绑定关系只在函数调用时生效，在调用结束后解除

# 二 形参与实参的具体使用
# 2.1.位置参数:位置即顺序，位置参数指的是按顺序定义的参数
# 位置形参：在定义函数阶段，按照从左到右的顺序依次定义的形参（依次定义的“变量名”）
# 特点：必须被传值，多一个不行，少一个也不行
# def register(name, age, sex):  # 定义位置形参：name，age，sex，三者都必须被传值
#     print('Name:%s Age:%s Sex:%s' % (name, age, sex))
#
# # register()  # TypeError：缺少3个位置参数
# register("小明", "28", "男")  # TypeError：缺少3个位置参数
# 位置实参：在调用函数阶段，按照从左到右的顺序 依次定义的实参（依次传入的值）
# 特点：按照从左到右的顺序与形参一一对应

# 2.2 关键字参数
# 关键字实参：在调用函数时，实参可以是key=value的形式传入的值
# 特点：可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值
# register(sex='male',name='lili',age=18)  # Name:lili Age:18 Sex:male
# 位置实参与关键字实参的混合使用：
# 必须保证关键字参数在位置参数后面，
# 且不可以对一个形参重复赋值
# register('lili', sex='male', age=18) #正确使用
# register(name='lili', 18, sex='male') #SyntaxError：关键字参数name=‘lili’在位置参数18之前
# register('lili', sex='male', age=18, name='jack') #TypeError：形参name被重复赋值

# 2.3 默认参数
# 默认参数：在定义函数时，就已经为形参赋值，这类形参称之为默认参数
# 特点：在定义阶段就已经被赋值，意味着在调用阶段可以不用为其赋值
# 当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。
# 例如编写一个注册学生信息的函数，如果大多数学生的性别都为男，那完全可以将形参sex定义成默认参数
# def register(name, age, sex='male'): #默认sex的值为male
#     print('Name:%s Age:%s Sex:%s' % (name, age, sex))
# 定义时就已经为参数sex赋值，意味着调用时可以不对sex赋值，这降低了函数调用的复杂度
# register('tom', 17)  # 大多数情况,无需为sex传值,默认为male
# Name:tom Age:17 Sex:male
# register('Lili', 18,' female') #少数情况,可以为sex传值female
# Name:Lili Age:18 Sex:female

# 位置形参和默认形参混用：
# 1.默认形参必须在位置形参之后
# def foo(x, y=10):
#     print(x, y)
#
# foo(1)
# 2.默认形参的值仅在函数定义阶段被赋值一次,准确的说被赋予的是值的内存地址
# 示范一：
# m = 1
# def foo(x, y=m):
#     print(x, y)
#
# m=5 #定义阶段arg已被赋值为1，此处的修改与默认参数arg无任何关系
# foo(1)
# 示范二：
# m = [111]
# def foo(x, y=m):  # y=[111]的内存地址
#     print(x, y)
#
# m.append(2222)
# foo(1)
# 3.虽然默认值可以被指定为任意数据类型，但是不推荐使用可变类型
# 函数最理想状态：函数的调用只跟函数本身有关系，不受外界的影响
# def func(x, y, z, l=None):  # 规范：不要把默认参数写成可变类型：l=[]
#     if l is None:
#         l = []
#     l.append(x)
#     l.append(y)
#     l.append(z)
#     print(l)
#
# # func(1, 2, 3)
# func(1, 2, 3, [4, 5])

# 2.4 可变长度的参数（*与**的用法）
# 参数的长度可变指的是在调用函数时，实参的个数可以不固定。
# 而在调用函数时，实参的定义无非是按位置或者按关键字两种形式，这就要求形参提供两种解决方案
# 来分别处理两种形式的可变长度的参数

# 2.4.1 可变长度的位置参数
# 形参格式：*形参：形参名前加号,那么在调用函数时，溢出的位置实参，都会被接收，
# 以元组的形式保存下来赋值给该形参
# 注意:*后可以是任意名字，但是规范应该是args
# def foo(x, y, z=1, *args):  # 在最后一个形参名args前加*号
#     print(x, y, z, args)
#
# foo(1, 2, 3, 4, 5, 6, 7)  # 实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，
# 以元组的形式保存下来，赋值给args，即args=(4, 5, 6,7)

# def my_sum(*args):
#     res = 0
#     for item in args:
#         res += item
#     print(res)
# my_sum(1, 2, 3, 4)

# 如果我们事先生成了一个列表,仍然是可以传值给*args的
# def foo(x, y, *args):
#     print(x, y, args)
#
# L = [3, 4, 5]
# foo(1, 2, *L)  # *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)
# 注意：如果在传入L时没有加*,那L就只是一个普通的位置参数了
# foo(1, 2, L)  # 仅多出一个位置实参L # 1 2 ([3, 4, 5],)
# 如果形参为常规的参数（位置或默认），实参仍可以是*的形式
# def foo(x, y, z=3):
#     print(x, y, z)
#
# foo(*[1,2])  # 等同于foo(1,2)

# 2.4.2 可变长度的关键字参数
# 如果在最后一个形参名前加**号,那么在调用函数时，溢出的关键字参数，都会被接收，
# 以字典的形式保存下来赋值给该形参
# def foo(x, **kwargs): #在最后一个参数kwargs前加**
#     print(x, kwargs)

# foo(y=2, x=1, z=3) #溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs
# 1 {'y': 2, 'z': 3}
# 如果我们事先生成了一个字典,仍然是可以传值给**kwargs的
# def foo(x ,y, **kwargs):
#     print(x, y, kwargs)
#
# dic={'a':1,'b':2}
# foo(1, 2, **dic) # **dic就相当于关键字参数a=1，b=2，foo(1,2,**dic)等同foo(1,2,a=1,b=2)

# 注意：如果在传入dic时没有加**,那dic就只是一个普通的位置参数了
# foo(1, 2, dic) #TypeError:函数foo只需要2个位置参数，但是传了3个

# 如果形参为常规参数（位置或默认），实参仍可以是**的形式
# def foo(x, y, z=3):
#     print(x, y, z)
#
# foo(**{'x':1,'y':2}) #等同于foo(y=2,x=1)


# 混用*与**：*args必须要在**kwargs之前
# def func(*args, **kwargs):
#     print(args)
#     print(kwargs)
#
# func(1, 2, 3, a=4, b=5, c=6)

# 解释下述形式,即函数wrapper的参数特点是什么
# *形参：汇总溢出的实参成元祖
# *实参：拆分成多个元素
# **关键字型参：汇总溢出的关键字实参成字典
# **关键字实参：拆分成a=1，b=2...
def index(x, y, z):
    print(x, y, z)


def wrapper(*args, **kwargs):  # args=(1,) kwargs={"y":2,"z":3}
    index(*args, **kwargs)
    # index(*(1,), **{"y":2,"z":3})
    # index(1,z=3,y=2)


wrapper(1, z=3, y=2)
